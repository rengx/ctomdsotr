<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ctomdsotr</title>
  <subtitle>心怀千里梦想，依然行在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ctomdsotr.com/"/>
  <updated>2017-07-02T16:10:19.277Z</updated>
  <id>http://ctomdsotr.com/</id>
  
  <author>
    <name>Alwill</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>书单</title>
    <link href="http://ctomdsotr.com/%E4%B9%A6%E5%8D%95.html"/>
    <id>http://ctomdsotr.com/书单.html</id>
    <published>2017-07-02T16:02:59.000Z</published>
    <updated>2017-07-02T16:10:19.277Z</updated>
    
    <content type="html"><![CDATA[<p>《当下的力量》<br>《The Art of Scalability》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《当下的力量》&lt;br&gt;《The Art of Scalability》&lt;/p&gt;

    
    </summary>
    
      <category term="Study" scheme="http://ctomdsotr.com/categories/Study/"/>
    
    
      <category term="读书" scheme="http://ctomdsotr.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>AspectJ学习</title>
    <link href="http://ctomdsotr.com/AspectJ%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://ctomdsotr.com/AspectJ学习.html</id>
    <published>2017-06-24T15:31:12.000Z</published>
    <updated>2017-07-07T04:56:20.158Z</updated>
    
    <content type="html"><![CDATA[<p>AspectJ ，Java语言的AOP(Aspect-Oritend Programming)扩展。</p>
<h1 id="Introduction-to-AspectJ"><a href="#Introduction-to-AspectJ" class="headerlink" title="Introduction to AspectJ"></a>Introduction to AspectJ</h1><p><em>（主要是在官网学习时的笔记）</em></p>
<p>1.pointcuts 切入点<br>2.advice<br>3.inter-type declarations 类型间声明<br>4.aspects 方面</p>
<p>pointcuts和advice动态的影响程序流，inter-type declarations静态的影响程序的类层级，aspects封装了这些构造。<br>(pointcuts and advice dynamically affect program flow, inter-type decalrations statically affects program’s class hierarchy, and aspects encapsulate these new constructs.)</p>
<p>join point是程序流中定义明确的点，pointcut会挑选处join point和这些点处的值，advice是程序运行至join point时执行的代码。这些就是AspectJ的动态部分。<br>(A <em>join point</em> is a well-defined point in the program flow. A <em>pointcut</em> picks out certain join points and values at those points. A piece of <em>advice</em> is code that is excuted when a join point is reached. These are the dynamic part of AspectJ.)</p>
<p>AspectJ 还有不同种类的inter-type declarations, 这些，允许程序员修改程序的结果，也就是类的数量和类之间的关系。<br>(AspectJ alse has defferent kinds of <em>inter-type declarations</em> that allow the programmer to modify a program’s sturcture, namely, the members of classes and the relationship between classes.)</p>
<p>AspectJ的aspect是横切问题的模块化单元。<br>(AspectJ’s <em>aspect</em> are the unit of modularity for crosscutting concerns. They behave somewhat like Java classes, but may alse include pointcuts, advice and inter-type declarations.)</p>
<h2 id="The-Dynamic-Join-Point-Model"><a href="#The-Dynamic-Join-Point-Model" class="headerlink" title="The Dynamic Join Point Model"></a>The Dynamic Join Point Model</h2><p>The join point model provides the common frame of reference that make it possible to define the dynamic structure of crosscutting concerns.<br>AspectJ provides for many kinds of join points. One of them is method call join point.</p>
<p>method call join points 包含接收防范调用的对象的行为，它包括构成方法调用的所有行为，从所有参数被评估之后开始，还包括返回（正常返回或抛出异常）。<br>(A method call join points encompasses the actions of an object receiving a method call. It includes all the actions that comprise a method call, starting after all arguments are evaluated up to and including return (either normally or by throwing an exception).)</p>
<p>运行时的每次方法调用都是不同的join point，尽管它来自程序中相同的调用表达式。许多其他的join point可以在一个method call join point执行的同时运行——当执行方法体时发生的所有连接点，以及在这些方法中调用的方法。我们说这些join point在原始join point的动态上下文中执行。<br>(Each method call at runtime is a different join point, even if it comes from the same call expression in the program. Many other join point may run while a method call join point is executing – all the join points that happen while executing the method body, and in those methods called from the body. we say that these join points execute in the dynamic context of the original call join point.)</p>
<h2 id="Pointcuts"><a href="#Pointcuts" class="headerlink" title="Pointcuts"></a>Pointcuts</h2><p>基于显式的方法签名的列举，即name-based crosscutting。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">call(void Point.setX(int))</div><div class="line"></div><div class="line">//2</div><div class="line">call(void Point.setX(int)) ||</div><div class="line">call(void Point.setY(int))</div><div class="line"></div><div class="line">//3</div><div class="line">pointcut move():</div><div class="line">    call(void FigureElement.setXY(int,int)) ||</div><div class="line">    call(void Point.setX(int))              ||</div><div class="line">    call(void Point.setY(int))              ||</div><div class="line">    call(void Line.setP1(Point))            ||</div><div class="line">    call(void Line.setP2(Point));</div></pre></td></tr></table></figure></p>
<p>基于方法的属性而不是准确的名字来指定pointcut，即property-based crosscutting。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//wildcards</div><div class="line">call(void Figure.make*(..))</div><div class="line">call(public * Figure.* (..))</div><div class="line"></div><div class="line">//cflow</div><div class="line">cflow(move())</div></pre></td></tr></table></figure></p>
<h2 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h2><p>pointcuts选出join point，但是它并没有做什么事情。为了实现横切行为，我们使用advice。</p>
<p>Advice brings together a pointcut(to pick out join points) and a body of code(to run at each of those join points).</p>
<p>AspectJ有几个不同的advice。<br><em>before advice</em><br><em>after advice</em>，包括after returning, after throwing, after</p>
<h3 id="Exposing-context-in-Pointcuts"><a href="#Exposing-context-in-Pointcuts" class="headerlink" title="Exposing context in Pointcuts"></a>Exposing context in Pointcuts</h3><p>Pointcuts not only pick out join points, they can alse expose part of execution context at their join points.Values exposed by a pointcut can be used in the body of advice declarations.</p>
<p>An advice declaration has a parameter list(like a method)that gives names to all the pieces of context that it uses. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">after(FigureElement fe, int x, int y) returning:</div><div class="line">        ...SomePointcut... &#123;</div><div class="line">    ...SomeBody...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The body of the advice uses the names just like method parameters, so<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">after(FigureElement fe, int x, int y) returning:</div><div class="line">        ...SomePointcut... &#123;</div><div class="line">    System.out.println(fe + &quot; moved to (&quot; + x + &quot;, &quot; + y + &quot;)&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装aspectj"><a href="#安装aspectj" class="headerlink" title="安装aspectj"></a>安装aspectj</h2><p>aspect安装下载，<br>官网地址，速度可能会慢：<a href="http://www.eclipse.org/aspectj/downloads.php#install" target="_blank" rel="external">http://www.eclipse.org/aspectj/downloads.php#install</a><br>也可使用：<a href="http://download.csdn.net/detail/smaiiboy/9477346" target="_blank" rel="external">http://download.csdn.net/detail/smaiiboy/9477346</a></p>
<p>笔者下载的是最新稳定版（Latest Stable Release）：aspectj-1.8.10.jar（下载时间2017/7/7），这是一个可执行jar，有别于我们通常使用的静态jar包。下载后使用jar命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar &#123;jar包位置&#125;/aspectj-1.8.10.jar</div></pre></td></tr></table></figure></p>
<p>运行后会看到安装界面，安装后如下：<br><img src="index_files/d88b0746-1755-488e-b822-addca3002f92.png" alt="安装成功图"></p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>AspectJ需要专门的JDK来编译，可以使用IDE插件比如Eclipse AJDT开发，也可以使用注解方式（AspectJ1.5版本或更新）。</p>
<h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><p>笔者使用Maven来构建的，使用的Mojo的aspectj-maven-plugin <a href="http://mojo.codehaus.org/aspectj-maven-plugin/" target="_blank" rel="external">http://mojo.codehaus.org/aspectj-maven-plugin/</a> 。<br>（从<a href="http://blog.csdn.net/zl3450341/article/details/7673942" target="_blank" rel="external">http://blog.csdn.net/zl3450341/article/details/7673942</a> 获悉的Maven编译插件，感谢博主！）</p>
<p>pom.xml配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">    &lt;groupId&gt;com.ctomdsotr.study&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;aspect&lt;/artifactId&gt;</div><div class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</div><div class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;name&gt;aspect Maven Webapp&lt;/name&gt;</div><div class="line">    &lt;url&gt;http://maven.apache.org&lt;/url&gt;</div><div class="line">    &lt;properties&gt;</div><div class="line">        &lt;aspectjrt.version&gt;1.8.10&lt;/aspectjrt.version&gt;</div><div class="line">    &lt;/properties&gt;</div><div class="line">    &lt;dependencies&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;$&#123;aspectjrt.version&#125;&lt;/version&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line"></div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;$&#123;aspectjrt.version&#125;&lt;/version&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line"></div><div class="line">    &lt;build&gt;</div><div class="line">        &lt;pluginManagement&gt;</div><div class="line">            &lt;plugins&gt;</div><div class="line">                &lt;plugin&gt;</div><div class="line">                    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</div><div class="line">                    &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;</div><div class="line">                    &lt;version&gt;1.8&lt;/version&gt;</div><div class="line">                    &lt;configuration&gt;</div><div class="line">                        &lt;!-- 选择大于1.5的版本，因为使用的是aspectj的注解方式 --&gt;</div><div class="line">                        &lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;</div><div class="line">                        &lt;source&gt;1.8&lt;/source&gt;</div><div class="line">                        &lt;target&gt;1.8&lt;/target&gt;</div><div class="line">                        &lt;sources&gt;</div><div class="line">                            &lt;source&gt;</div><div class="line">                                &lt;basedir&gt;src/main/java&lt;/basedir&gt;</div><div class="line">                                &lt;includes&gt;</div><div class="line">                                    &lt;include&gt;**/UserAspect.java&lt;/include&gt;</div><div class="line">                                    &lt;include&gt;**/UserServiceImpl.java&lt;/include&gt;  &lt;!-- 不仅是aspect,还有其他的，不然只会编译aspect，没有办法测试，运行时会报错误: 找不到或无法加载主类 --&gt;</div><div class="line">                                &lt;/includes&gt;</div><div class="line">                            &lt;/source&gt;</div><div class="line">                        &lt;/sources&gt;</div><div class="line">                    &lt;/configuration&gt;</div><div class="line">                    &lt;executions&gt;</div><div class="line">                        &lt;execution&gt;</div><div class="line">                            &lt;goals&gt;</div><div class="line">                                &lt;goal&gt;compile&lt;/goal&gt;</div><div class="line">                            &lt;/goals&gt;</div><div class="line">                        &lt;/execution&gt;</div><div class="line">                    &lt;/executions&gt;</div><div class="line">                &lt;/plugin&gt;</div><div class="line">            &lt;/plugins&gt;</div><div class="line">        &lt;/pluginManagement&gt;</div><div class="line">    &lt;/build&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure></p>
<p>源码会放在github上。</p>
<p>具体的步骤笔者不在赘述，从官网或搜索引擎上都能找到资料，足以帮助开发者学习。笔者列举一下自己遇到的问题，如果有其他人正好遇到，希望能有所帮助。</p>
<h4 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h4><p>配置好上述pom，然后使用mvn aspectj:complile 编译，在eclipse中，就是在项目或pom.xml上右键”Run As”，选择”Build build…”，填入”aspectj:complile” 。</p>
<h4 id="编译时报错（没有加-aspect）"><a href="#编译时报错（没有加-aspect）" class="headerlink" title="编译时报错（没有加@aspect）"></a>编译时报错（没有加@aspect）</h4><h4 id="编译时提示http-servet-httpServert"><a href="#编译时提示http-servet-httpServert" class="headerlink" title="编译时提示http.servet.httpServert"></a>编译时提示http.servet.httpServert</h4><h4 id="编译成功，但是没有执行切面的advices"><a href="#编译成功，但是没有执行切面的advices" class="headerlink" title="编译成功，但是没有执行切面的advices"></a>编译成功，但是没有执行切面的advices</h4><h4 id="编译成功，但是只执行切面的advice-原来的方法被覆盖了，没有执行"><a href="#编译成功，但是只执行切面的advice-原来的方法被覆盖了，没有执行" class="headerlink" title="编译成功，但是只执行切面的advice,原来的方法被覆盖了，没有执行"></a>编译成功，但是只执行切面的advice,原来的方法被覆盖了，没有执行</h4><h3 id="使用AJDT开发"><a href="#使用AJDT开发" class="headerlink" title="使用AJDT开发"></a>使用AJDT开发</h3><p>官网下载地址：<a href="http://www.eclipse.org/aspectj/downloads.php" target="_blank" rel="external">http://www.eclipse.org/aspectj/downloads.php</a><br>（AJDT for Eclipse：<a href="http://www.eclipse.org/ajdt/" target="_blank" rel="external">http://www.eclipse.org/ajdt/</a> ，其他IDEs: <a href="http://www.eclipse.org/aspectj/downloads.php#ides" target="_blank" rel="external">http://www.eclipse.org/aspectj/downloads.php#ides</a> ）<br><em>（笔者只是写了一个例子，先贴一下代码）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**先写一个java class*/</div><div class="line">package com.ctomdsotr.study.aspectj.user;</div><div class="line">public class User &#123;</div><div class="line">    private String userName;</div><div class="line">    private String userId;</div><div class="line"></div><div class="line">    public void addUser(String userId, String userName) &#123;</div><div class="line">        this.userId = userId;</div><div class="line">        this.userName = userName;</div><div class="line">        System.out.println(&quot;added &quot;+userId);</div><div class="line">    &#125;</div><div class="line">    public String getUser(String userId) &#123;</div><div class="line">        return userName;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        User user = new User();</div><div class="line">        user.addUser(&quot;1&quot;, &quot;2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**创建一个切面*/</div><div class="line">package com.ctomdsotr.study.aspectj.user.aspect;</div><div class="line">import com.ctomdsotr.study.aspectj.user.User;</div><div class="line">public aspect FirstAspect &#123;</div><div class="line">    pointcut addUser(String userId, String userName): execution(void User.addUser(String, String)) &amp;&amp; args(userId, userName);</div><div class="line">    after(String userId, String userName) returning : addUser(userId, userName)&#123;</div><div class="line">        System.out.println(userId + &quot;:&quot; + userName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**最后运行User，控制台输出*/</div><div class="line">added 1</div><div class="line">1:2</div></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>AspectJ Doc <a href="http://www.eclipse.org/aspectj/doc/released/adk15notebook/ataspectj.html" target="_blank" rel="external">http://www.eclipse.org/aspectj/doc/released/adk15notebook/ataspectj.html</a><br>Maven Plugin <a href="http://www.mojohaus.org/aspectj-maven-plugin/index.html" target="_blank" rel="external">http://www.mojohaus.org/aspectj-maven-plugin/index.html</a><br>Maven Jar <a href="http://mvnrepository.com/artifact/org.aspectj" target="_blank" rel="external">http://mvnrepository.com/artifact/org.aspectj</a><br>AspectJ 安装文件 <a href="http://download.csdn.net/detail/smaiiboy/9477346" target="_blank" rel="external">http://download.csdn.net/detail/smaiiboy/9477346</a><br>两个挺好的博客 <a href="http://blog.csdn.net/zl3450341/article/details/7673942" target="_blank" rel="external">http://blog.csdn.net/zl3450341/article/details/7673942</a> <a href="http://blog.csdn.net/ccj659/article/details/53302951" target="_blank" rel="external">http://blog.csdn.net/ccj659/article/details/53302951</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AspectJ ，Java语言的AOP(Aspect-Oritend Programming)扩展。&lt;/p&gt;
&lt;h1 id=&quot;Introduction-to-AspectJ&quot;&gt;&lt;a href=&quot;#Introduction-to-AspectJ&quot; class=&quot;headerl
    
    </summary>
    
      <category term="Programming" scheme="http://ctomdsotr.com/categories/Programming/"/>
    
    
      <category term="AOP" scheme="http://ctomdsotr.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想之面向对象</title>
    <link href="http://ctomdsotr.com/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://ctomdsotr.com/Java编程思想之面向对象.html</id>
    <published>2017-06-06T16:46:50.000Z</published>
    <updated>2017-07-02T15:39:58.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h1><h2 id="用引用操纵对象"><a href="#用引用操纵对象" class="headerlink" title="用引用操纵对象"></a>用引用操纵对象</h2><p>在java中，一切被视为对象，操作对象的标识符实际上是对象的一个“引用”（reference）。<br>书中以遥控器比引用，电视机比对象，我们直接操作的是遥控器（引用），再由遥控器来调控电视机（对象），而且我们可以在房间中走动的同时调控电视机，只需携带遥控器而不是电视机。此外，即使没有电视机，遥控器也可以独立存在。<br>这个例子可以说明，我们可以使用引用，在不同的地方操作对象；我们也可以拥有一个引用，这个引用也不一定必须有一个对象与之关联，但是这仅限于在我们使用这个引用之前。</p>
<h2 id="必须由你创建所有对象"><a href="#必须由你创建所有对象" class="headerlink" title="必须由你创建所有对象"></a>必须由你创建所有对象</h2><p>在使用引用之前，必须关联一个对象。</p>
<h3 id="对象存储在哪"><a href="#对象存储在哪" class="headerlink" title="对象存储在哪"></a>对象存储在哪</h3><p>程序运行时，对象是怎么进行放置安排的呢？</p>
<ol>
<li>寄存器。因为它位于CPU内部，所以存取最快，当然数量也极其有限（书中用了“极其有限”）。我们不能直接控制，也感觉不到它的存在。</li>
<li>堆栈。位于RAM（随机访问存储器），是存放数据的一种内存区域（<a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" title="stack的三种含义" target="_blank" rel="external">stack的三种含义</a>）。堆栈是有结构的，数据结构就是栈，每个区块大小固定，适宜存大小固定的数据，比如如对象的引用，基本数据类型。</li>
<li>堆。位于RAM，没有结构，大小也不固定，可以任意存放。用于存放所有的对象。</li>
<li>常量。直接存放在程序代码中（反编译class文件即可看到）。</li>
<li>非RAM存储，比如数据库等。</li>
</ol>
<h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>前面我们知道所有对象都要使用new 创建，并且存在堆中。但是，一些比较小的、简单的变量，这样做不是很有效。这些变量，不用new来创建，是非引用类型的变量。这些变量直接存储值（引用类型变量存储的是对象的地址），位于堆栈中，因此更高效。<br>这些变量存放于堆栈，因此大小就要是固定的，在java中，也不像其他语言随机器硬件架构的变化而变化。这也是java具有可移植性的原因之一。<br>基本类型有boolean/byte/char/short/int/long/float/double/void。</p>
<h2 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h2><ol>
<li>作用域</li>
<li>对象的作用域<br>基本类型，在作用域终点时就会从堆栈中移除；对象类型的变量，对象的引用在作用域终点会消失，但是对象依然会在堆中占据内存空间，直到被垃圾回收机制处理。</li>
</ol>
<h2 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h2><p>我们可以的的用户class（关键字）+空格+类型名，创建一个新的数据类型。<br>一旦定义了一个类，就可以在类中设置两种类型的元素:字段（数据成员）和方法（成员方法）。字段可以是任意类型的对象，可以是基本类型，也可以是引用类型（某个对象的引用）。</p>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>基本成员（基本类型成员）具有默认值，即便初始化（基本类型仅在作为成员变量时，java才会给定默认值）。但是，引用类型的成员为NULL，所以引用类型在创建后要先关联一个对象后才能被使用。</p>
<h3 id="方法、参数和返回值"><a href="#方法、参数和返回值" class="headerlink" title="方法、参数和返回值"></a>方法、参数和返回值</h3><p>Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成：名称、参数、返回值和方法体。方法名和参数（合称方法签名）唯一地标识一个方法。<br>方法只有通过对象才能被调用。<br>参数列表，指定要传递给方法什么样的信息，这些信息同Java的其他信息一样也是对象。像Java中任何传递对象的场合一样，这里传递的实际也是引用（基本类型是例外）。</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>static域和方法，不与包含它的那个类的任何对象关联在一起。非static域和方法必须与特定的对象关联。<br>在使用static域和方法时，可以使用类来调用（也是推荐的方式），也可以使用其所属类的对象。<br>static域只有一份存储空间，不过创建了多少个其所属类的对象。</p>
<h1 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h1><blockquote>
<p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。<br>初始化和清理正是涉及安全的两个问题。<br>许多C程序的错误都源于程序员忘记初始化变量。特别是在使用程序库时，如果用户不知道如何初始化库的构件（或者用户必须初始化的其他东西），更是如此。清理是一个特殊的问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一直得不到释放，结果是资源（特别是内存）用尽。</p>
</blockquote>
<p>引用了书中的原话，很清晰。为什么要初始化，以及java中约定用构造器初始化的意义，即使用程序库的时候，知道如何初始化并且也不会忘记。“清理”说的也很清楚。</p>
<h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>构造器采用与类相同的名称。在创建对象时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ClassName();</div></pre></td></tr></table></figure></p>
<p>将会为对象分配存储空间，并调用相应的构造器。构造器是一种特殊的方法，没有返回值（这与返回值为空（void）不同）。<br>不接受任何参数的构造器叫做默认构造器，Java术语为无参构造器。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>重载，用于表示相同但有细微差别的概念。将方法重载用于构造器，可以提供创建对象的多种方式，非构造器方法也可以使用。<br>区分重载方法：每个重载的方法都必须有一个独一无二的参数类型列表。而且，参数顺序也可以区分（不过，一般情况别这么做，会使代码难以维护）。但是，返回值是不能用于区分重载的。<br>基本类型的重载，基本类型能从一个“较小”的类型自动提升至一个“较大”的类型。char略有不同，如果找不恰好接收char参数的方法，会提升为int。基本类型很有必要从<a href="http://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="external">这里学习</a>。</p>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>如果，你的类的中没有写构造器，则编译器就会自动帮你创建一个默认构造器；但是，如果你定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器了。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。<br>不过，在方法内部调用同一个类的另一个方法，就不必使用this了，因为编译器自动帮你添加。只有当需要明确指出对当对象的引用时，才需要使用this，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Lear&#123;</div><div class="line">  int i;</div><div class="line">  Leaf increament()&#123;</div><div class="line">     i++;</div><div class="line">     return this;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>this关键字对于将当前对象传递给其他方法也很有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class ThisDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Person person = new Person();</div><div class="line">        person.eat(new Apple());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Person &#123;</div><div class="line">    public void eat(Apple apple) &#123;</div><div class="line">        Apple peeled = apple.getPeeled();</div><div class="line">        System.out.println(&quot;Yummy&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Apple &#123;</div><div class="line">    Apple getPeeled() &#123;</div><div class="line">        return Peeler.peel(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Peeler &#123;</div><div class="line">    static Apple peel(Apple apple) &#123;</div><div class="line">        // remove peel</div><div class="line">        return apple;</div><div class="line">    &#125;</div><div class="line">&#125;  /*output:</div><div class="line">Yummy</div><div class="line">*///:~</div></pre></td></tr></table></figure></p>
<p>this还用与在构造器中调用构造器。</p>
<h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3><p>static方法，就是没有this的方法。</p>
<h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><p>Java垃圾回收器负责回收无用对象占据的内存资源。<br>但是，也有特殊情况，假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放经由new分配的内存，所以它不知道如何释放这样的“特殊”内存。</p>
<p>A a = new A(1);<br>a = new A(2); // new A(1)产生的对象将被丢弃，并等待回收（如果没有别的引用关联它）。</p>
<h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>Java尽力保证：所有变量在使用前都能得到恰当的初始化。<br>对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。<br>对于类的数据成员（即字段），如果是基本类型，在创建对象时会有一个初始值（数字类型为0，布尔为false，char为0且打印为空白）；如果是引用类型，就会获得一个特殊值null。</p>
<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>可以使用构造器来进行初始化。但是，这无法阻止自动初始化的进行，成员初始化在构造初始化之前进行。</p>
<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>在类内部，变量定义的先后顺序决定了初始化的顺序。<br>即使，变量定义方法定义之间，他们仍旧会在任何方法（包括构造器）被调用之前得到初始化。</p>
<h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>静态变量只在类的第一个对象（或者第一次访问静态数据）的时候被初始化，此后无论创建多少对象，都不会再次被初始化，因此静态数据只占用一份内存区域。<br>static关键字不能应用于<strong>局部变量</strong>，只能作用于<strong>域</strong>。（注意Java术语）。<br><strong>对象创建过程</strong>，假设有个名为Dog的类：</p>
<ol>
<li>当<strong>首次</strong>创建类型为Dog的对象时，或者Dog类的静态方法/静态域<strong>首次</strong>被访问时，Java解释器必须查找类路径，已定位Dog.class文件。</li>
<li>然后载入Dog.class，有关静态初始化的多有动作都会执行。因此静态初始化只在Class对象首次加载的时候执行一次。</li>
<li>当用new Dog()创建对象时，首先在堆上为Dog对象分配足够的存储空间。</li>
<li>这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据设置为默认值，而引用则被设置为null。</li>
<li>执行所有出现于字段定义处的初始化动作。</li>
<li>执行构造器。</li>
</ol>
<h3 id="显式静态初始化"><a href="#显式静态初始化" class="headerlink" title="显式静态初始化"></a>显式静态初始化</h3><p>Java允许将多个静态初始化动作组织成一个特殊的“静态字句”（静态块）。就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class StaticDemo&#123;</div><div class="line">  static int i;</div><div class="line">  static&#123;</div><div class="line">    i=47;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管看上去像个方法，但实际只是一段跟在static后的代码。</p>
<h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p><strong>实例</strong>初始化。初始化每个对象的非静态变量。</p>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>数组，相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。<br>定义数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int[] a;</div><div class="line">int a1[];</div></pre></td></tr></table></figure></p>
<p>编译器不允许定义数组时指定大小。现在拥有的就是一个引用，这和其他类的引用和对象是一样的。<br>为了给数组分配存储空间，必须写初始化表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = new int[2]; // 数组定义之后的任意地方都可以使用</div><div class="line">int[] a2 = &#123;0, 1&#125;; // 这种初始化方式只能在数组定义时使用</div></pre></td></tr></table></figure></p>
<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class NewVarArgs &#123;</div><div class="line"></div><div class="line">    // 可变参数列表</div><div class="line">    static void printArray(Object... args) &#123;</div><div class="line">        for (Object o : args) &#123;</div><div class="line">            System.out.print(o);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        printArray(new Integer(47), new Float(3.14), new Double(11.11));</div><div class="line">        printArray(47, 3.14, 11.11);</div><div class="line">        printArray(&quot;one&quot;, &quot;two&quot;);</div><div class="line">        // 数组</div><div class="line">        printArray(new Integer[] &#123; 1, 2, 3 &#125;);</div><div class="line">        printArray();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你有一组事务，可以把它们作为列表传递；而如果你已经有一个数组，该方法可以把它们作为可变参数列表来接受。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h1 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h1><h2 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h2><p>将对象引用置于新类中就是使用组合。</p>
<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类的时候，总是在继承，除非已明确指出要从其他类继承，否则就是在隐式的从Java的标准根类Object进行继承。</p>
<p>组合的语法比较平实，但继承是使用特殊的一种语法，即<strong>extends</strong>。</p>
<h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>当创建一个导出类的对象时，该对象会包含一个基类的子对象。这个子对象与用基类直接创建对象是一样的，但这个子对象被包装在导出类对象内部。因此，对基类子对象的初始化也至关重要，而且也仅有一种方法：<br>在构造器中调用基类的构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力。</p>
<p>当读到这句话的时候，它对自己有一定的触动。因为，在以往的编程经历中，设计一个类的时候，几乎都忽略了构造器的这种能力。</p>
<p>对于基类默认构造器，Java会自动在导出类的构造器中插入对基类构造器的调用。<br>对于基类带参数的构造器，必须使用关键字<strong>super</strong>显式的编写调用基类构造器的语句。而且，调用基类构造器必须位于导出类构造器中的最前面。否则，编译报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Demo(int i)&#123;</div><div class="line">  super(i);  // 第一句</div><div class="line">  // 其他处理</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>将一个成员对象置于所要构造的新类中（就像组合），与此同时在新类中暴露了该成员对象的所有方法（就像继承）。（当然，不一定是所有方法）</p>
<p>书中太空船的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 太空船控制模块</div><div class="line"> * </div><div class="line"> * @author rengzailushang</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class SpaceShipControls &#123;</div><div class="line">	void forward(int velocity) &#123;</div><div class="line">	&#125;</div><div class="line">	void back(int velocity) &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用继承，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 使用继承建造太空船</div><div class="line"> * </div><div class="line"> * @author rengzailushang</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class SpaceShip extends SpaceShipControls&#123;</div><div class="line">	private String name;</div><div class="line">	public SpaceShip(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，SpaceShip并非真正的SpaceShipControls类型。所以，代理可以解决这一问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 使用代理建造太空船</div><div class="line"> * </div><div class="line"> * @author rengzailushang</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class SpaceShip2 &#123;</div><div class="line">	private String name;</div><div class="line">	private SpaceShipControls control = new SpaceShipControls();</div><div class="line">	public SpaceShip2(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public void forward(int velocity) &#123;</div><div class="line">		control.forward(velocity);</div><div class="line">	&#125;</div><div class="line">	public void back(int velocity) &#123;</div><div class="line">		control.back(velocity);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>书中还提到，尽管Java语言不直接支持代理，但是很多工具如JetBrains Idea IDE等可以自动生成上述例子。不过我没有去学习。</p>
<h2 id="结合使用组合和继承"><a href="#结合使用组合和继承" class="headerlink" title="结合使用组合和继承"></a>结合使用组合和继承</h2><h3 id="确保正确的清理"><a href="#确保正确的清理" class="headerlink" title="确保正确的清理"></a>确保正确的清理</h3><p>前面“初始化与清理”中，我们不知道Java垃圾回收器何时被调用，或者它是否被调用。因此，如果你想要某个类清理一些东西，就必须显式的编写一个特殊的方法来做这个事情，不要使用<strong>finalize()</strong>。</p>
<h3 id="名称屏蔽"><a href="#名称屏蔽" class="headerlink" title="名称屏蔽"></a>名称屏蔽</h3><p>如果Java的基类中拥有某个已被多次重载的方法，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。如果不想重载，可以使用@Override注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class OverrideDemo extends BaseClass&#123;</div><div class="line">	//@Override</div><div class="line">	//void base(String i)&#123;&#125; // 基类中必须有可重写的方法，否则编译报错</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	void base(int i)&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BaseClass &#123;</div><div class="line">	void base(int i)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="在组合与继承之间选择"><a href="#在组合与继承之间选择" class="headerlink" title="在组合与继承之间选择"></a>在组合与继承之间选择</h2><p>组合，通常用于想在新类中使用现有类的功能而非它的接口的情形。并且，一般组合成员都使用private，以隐藏具体实现。但是有时为了帮助该新类的使用者去了解怎么使用，也可以设置成public，但这是个例。</p>
<p>继承，使用某个现有类，并开发一个它的特殊版本。</p>
<p>“is-a”(是一个)的关系是用继承来表达，而“has-a”(有一个)的关系则用组合来表达。就像“车子”是一个“交通工具”，“太空船”有一个“控制模块”。</p>
<h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p>书中这样讲，“现在，我们以介绍完了继承，关键字<strong>protected</strong>最终具有了意义。”，我觉得这真是一种讲解的技巧。</p>
<p>在实际项目中，经常会想到将某些事物尽可能对世界隐藏起来，但仍然允许导出类的成员访问它们。<strong>protected</strong>就是这个作用。另外，protected也提供了包内访问权限。</p>
<p>最好的方式，还是将域保持为<strong>private</strong>：你应当一直保留“更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限。</p>
<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>继承技术最重要的就是，表现新类与基类间的关系，即“新类是现有类的一种类型”。</p>
<p>为什么叫“向上转型”？<br>传统的类继承图绘制：将根置于页面的顶端，然后逐渐向下。所以，由导出类转型为基类，在继承图上是向上移动的，因此为向上转型。<br>向上转型，是从一个专用类向较通用的类转换，所以总是安全的。</p>
<p><strong>是否真的需要向上转型</strong>也是判断是否应当使用继承的方法。虽然继承是OOP的重要技术与思想，但是并不意味着尽可能使用，相反，应慎用。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h3><ol>
<li><p>编译时常量<br>这种final数据，必须是基本类型，且在定义时必须赋值。编译器可以将常量代入到任何用到它的计算式中，这减轻了运行时的负担。</p>
</li>
<li><p>final引用类型<br>不变的是引用，不是对象。</p>
</li>
<li><p>空白final<br>可以在定义时不进行赋值，但是在构造器中必须赋值。</p>
</li>
<li><p>final参数<br>在方法中，参数的值不能修改。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3></li>
<li><p>方法锁定<br>以防继承类修改它的含义。<br>类中所有的private方法都隐式的使用了final。</p>
</li>
<li><p>效率<br>正常方式的执行方法调用机制是，将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值。在早期的java版本中，final方法可以跳过这一步骤。但是，在Java5/6时，虚拟机会自动处理效率问题，我们无需使用final去提高效率。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>不可被继承。</p>
</li>
</ol>
<h2 id="初始化及类的加载"><a href="#初始化及类的加载" class="headerlink" title="初始化及类的加载"></a>初始化及类的加载</h2><p>每个类的编译代码都存在于它自己独立的文件中，该文件只在需要使用程序代码时才会被加载。加载发生于：</p>
<ol>
<li>创建类的第一个对象时，</li>
<li>static域或static方法被访问时（构造器也是static方法，尽管没有显式的使用static关键字）。<br>所有的static对象和static代码段都会在加载时依程序中的顺序而以此初始化。</li>
</ol>
<p>通过一个例子了解包括继承在内的初始化过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 继承与初始化</div><div class="line"> * </div><div class="line"> * @author rengzailushang</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Beetle extends Insect &#123;</div><div class="line">	private int k = printInit(&quot;Beetle.k initialized&quot;);</div><div class="line">	public Beetle() &#123;</div><div class="line">		System.out.println(&quot;k=&quot; + k);</div><div class="line">		System.out.println(&quot;j=&quot; + j);</div><div class="line">	&#125;</div><div class="line">	public static int x2 = printInit(&quot;Beelte.x2 initialized&quot;);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(&quot;Beetle constructor&quot;);</div><div class="line">		Beetle b = new Beetle();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Insect &#123;</div><div class="line">	private int i = 9;</div><div class="line">	protected int j;</div><div class="line">	Insect() &#123;</div><div class="line">		System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</div><div class="line">		j = 39;</div><div class="line">	&#125;</div><div class="line">	public static int x1 = printInit(&quot;Insect.x1 initialized&quot;);</div><div class="line">	static int printInit(String s) &#123;</div><div class="line">		System.out.println(s);</div><div class="line">		return 47;</div><div class="line">	&#125;</div><div class="line">&#125; /* Output:</div><div class="line">Insect.x1 initialized</div><div class="line">Beelte.x2 initialized</div><div class="line">Beetle constructor</div><div class="line">i=9,j=0</div><div class="line">Beetle.k initialized</div><div class="line">k=47</div><div class="line">j=39</div><div class="line">*///:~</div></pre></td></tr></table></figure></p>
<ol>
<li>访问Beetle.main()(static方法)，加载器启动并找出Beetle类的编译代码。加载Beetle类，发现它有一个基类，于是继续加载基类（如果基类仍有基类，则继续加载，如此类推）。</li>
<li>根基类static初始化，下一个导出类，如此类推。</li>
<li>类加载完后，开始创建Beetle对象，首先对象中的成员被设为默认值（即便定义时被赋值，也要先设为默认值，再初始化）。</li>
<li>Beetle构造器被调用，先调用基类构造器（super()），基类中与3、4同。</li>
<li>基类构造器完成后，Beetle实例变量初始化，然后再执行构造器中的其他部分。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口。</p>
<p>开始设计时，优先考虑组合（或代理），只有确实必要时才使用继承。在设计一个系统时，目标应该是找到或创建某些类，每个类都有具体的用途，既不会太大（功能太多而难以复用），也不会太小。</p>
<p>当开始设计一个系统时，应该意识到程序开发是一种增量过程，而不是快速见效。</p>
<p>（对于我来说，这段总结值得思考，我经常在开始开发一个项目或功能时，追求过于全面的考虑）</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><strong>在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征</strong>。多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。<br><em>（读来觉得作者写的太好，译者也翻译出了味道，所以忍不住写下原句）</em><br>“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系（？不太明白怎么消除的）。在学习了“复用类”之后我知道，继承允许将对象视为它自身的类型或其基类型来加以处理。这种能力极其重要，因为它允许多种类型（从同一基类导出的）视为同一类型来处理，而同一份代码也就可以毫无差别的运行在这些不同类型之上了。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们是从同一基类导出而来的。<br>多态也称做动态绑定、后期绑定或运行时绑定。</p>
<p>（感觉，继承和多态描述的是同样的事物，只是从不同的角度。继承在于子类和基类，多态在于子类之间。）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一切都是对象&quot;&gt;&lt;a href=&quot;#一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;一切都是对象&quot;&gt;&lt;/a&gt;一切都是对象&lt;/h1&gt;&lt;h2 id=&quot;用引用操纵对象&quot;&gt;&lt;a href=&quot;#用引用操纵对象&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="语言" scheme="http://ctomdsotr.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java编程思想" scheme="http://ctomdsotr.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想</title>
    <link href="http://ctomdsotr.com/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.html"/>
    <id>http://ctomdsotr.com/Java编程思想.html</id>
    <published>2017-06-06T16:46:32.000Z</published>
    <updated>2017-06-07T00:31:37.687Z</updated>
    
    <content type="html"><![CDATA[<p>从学生时代到工作，java用了可以说相当长的时间了，但是系统的学习在第一次之后就没有了，所以这次重新学习，希望有新的理解。</p>
<p>以Bruce Eckel的经典之作《Java编程思想》为指导进行学习，先简要列举了学习顺序，如下：<br>1.面向对象编程思想<br>封装、继承、多态、接口<br>2.并发<br>3.集合及其原理<br>4.泛型、设计模式<br>5.io<br>6.异常<br>7.网络编程<br>8.运行时类型信息RTTI</p>
<p>将学习过程记录，仅作为自己的总结。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从学生时代到工作，java用了可以说相当长的时间了，但是系统的学习在第一次之后就没有了，所以这次重新学习，希望有新的理解。&lt;/p&gt;
&lt;p&gt;以Bruce Eckel的经典之作《Java编程思想》为指导进行学习，先简要列举了学习顺序，如下：&lt;br&gt;1.面向对象编程思想&lt;br&gt;封
    
    </summary>
    
      <category term="语言" scheme="http://ctomdsotr.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java编程思想" scheme="http://ctomdsotr.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://ctomdsotr.com/hello-world.html"/>
    <id>http://ctomdsotr.com/hello-world.html</id>
    <published>2017-06-04T14:20:04.187Z</published>
    <updated>2017-06-03T15:14:24.638Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初识推荐系统</title>
    <link href="http://ctomdsotr.com/%E5%88%9D%E8%AF%86%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://ctomdsotr.com/初识推荐系统.html</id>
    <published>2017-06-03T15:32:43.000Z</published>
    <updated>2017-06-04T04:45:49.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="EasyRec"><a href="#EasyRec" class="headerlink" title="EasyRec"></a>EasyRec</h3><p><a href="http://easyrec.org/" target="_blank" rel="external">http://easyrec.org/</a><br>EasyRec基于Java的开源推荐系统，B/S架构，具有可视化管理。提供了REST API和JavaScript API。<br>业务系统调用API将用户行为（浏览、购买、评价）存储于EasyRec（可配置mysql），推荐引擎会周期性进行分析并生成推荐，通过API提供出来。<br>相对比较简单，更像一个完整的产品。</p>
<h3 id="Mahout"><a href="#Mahout" class="headerlink" title="Mahout"></a>Mahout</h3><p><a href="http://mahout.apache.org/" target="_blank" rel="external">http://mahout.apache.org/</a><br>与EasyRec相比，Mahout同样基于Java，但要复杂，还没有研究。<br><a href="http://itindex.net/detail/49323-mahout-%E5%AD%A6%E4%B9%A0-mahout" target="_blank" rel="external">http://itindex.net/detail/49323-mahout-%E5%AD%A6%E4%B9%A0-mahout</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="http://www.cnblogs.com/haore147/p/5220026.html" target="_blank" rel="external">http://www.cnblogs.com/haore147/p/5220026.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;EasyRec&quot;&gt;&lt;a href=&quot;#EasyRec&quot; class=&quot;headerlink&quot; title=&quot;EasyRec&quot;&gt;&lt;/a&gt;EasyRec&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://easyrec.org/&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="Study" scheme="http://ctomdsotr.com/categories/Study/"/>
    
    
      <category term="Recommender system" scheme="http://ctomdsotr.com/tags/Recommender-system/"/>
    
  </entry>
  
</feed>
