---
title: Java编程思想之面向对象
date: 2017-06-07 00:46:50
tags: java编程思想
categories: 语言

---

# 一切都是对象

## 用引用操纵对象
在java中，一切被视为对象，操作对象的标识符实际上是对象的一个“引用”（reference）。
书中以遥控器比引用，电视机比对象，我们直接操作的是遥控器（引用），再由遥控器来调控电视机（对象），而且我们可以在房间中走动的同时调控电视机，只需携带遥控器而不是电视机。此外，即使没有电视机，遥控器也可以独立存在。
这个例子可以说明，我们可以使用引用，在不同的地方操作对象；我们也可以拥有一个引用，这个引用也不一定必须有一个对象与之关联，但是这仅限于在我们使用这个引用之前。

## 必须由你创建所有对象
在使用引用之前，必须关联一个对象。

### 对象存储在哪
程序运行时，对象是怎么进行放置安排的呢？

1. 寄存器。因为它位于CPU内部，所以存取最快，当然数量也极其有限（书中用了“极其有限”）。我们不能直接控制，也感觉不到它的存在。
2. 堆栈。位于RAM（随机访问存储器），是存放数据的一种内存区域（[stack的三种含义](http://www.ruanyifeng.com/blog/2013/11/stack.html "stack的三种含义")）。堆栈是有结构的，数据结构就是栈，每个区块大小固定，适宜存大小固定的数据，比如如对象的引用，基本数据类型。
3. 堆。位于RAM，没有结构，大小也不固定，可以任意存放。用于存放所有的对象。
4. 常量。直接存放在程序代码中（反编译class文件即可看到）。
5. 非RAM存储，比如数据库等。

### 特例：基本类型
前面我们知道所有对象都要使用new 创建，并且存在堆中。但是，一些比较小的、简单的变量，这样做不是很有效。这些变量，不用new来创建，是非引用类型的变量。这些变量直接存储值（引用类型变量存储的是对象的地址），位于堆栈中，因此更高效。
这些变量存放于堆栈，因此大小就要是固定的，在java中，也不像其他语言随机器硬件架构的变化而变化。这也是java具有可移植性的原因之一。
基本类型有boolean/byte/char/short/int/long/float/double/void。

## 永远不需要销毁对象
1. 作用域
2. 对象的作用域
基本类型，在作用域终点时就会从堆栈中移除；对象类型的变量，对象的引用在作用域终点会消失，但是对象依然会在堆中占据内存空间，直到被垃圾回收机制处理。

## 创建新的数据类型：类
我们可以的的用户class（关键字）+空格+类型名，创建一个新的数据类型。
一旦定义了一个类，就可以在类中设置两种类型的元素:字段（数据成员）和方法（成员方法）。字段可以是任意类型的对象，可以是基本类型，也可以是引用类型（某个对象的引用）。

### 成员
基本成员（基本类型成员）具有默认值，即便初始化（基本类型仅在作为成员变量时，java才会给定默认值）。但是，引用类型的成员为NULL，所以引用类型在创建后要先关联一个对象后才能被使用。

### 方法、参数和返回值
Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成：名称、参数、返回值和方法体。方法名和参数（合称方法签名）唯一地标识一个方法。
方法只有通过对象才能被调用。
参数列表，指定要传递给方法什么样的信息，这些信息同Java的其他信息一样也是对象。像Java中任何传递对象的场合一样，这里传递的实际也是引用（基本类型是例外）。

### static关键字
static域和方法，不与包含它的那个类的任何对象关联在一起。非static域和方法必须与特定的对象关联。
在使用static域和方法时，可以使用类来调用（也是推荐的方式），也可以使用其所属类的对象。
static域只有一份存储空间，不过创建了多少个其所属类的对象。


# 初始化与清理

> 随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。
初始化和清理正是涉及安全的两个问题。
许多C程序的错误都源于程序员忘记初始化变量。特别是在使用程序库时，如果用户不知道如何初始化库的构件（或者用户必须初始化的其他东西），更是如此。清理是一个特殊的问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一直得不到释放，结果是资源（特别是内存）用尽。

引用了书中的原话，很清晰。为什么要初始化，以及java中约定用构造器初始化的意义，即使用程序库的时候，知道如何初始化并且也不会忘记。“清理”说的也很清楚。

## 用构造器确保初始化
构造器采用与类相同的名称。在创建对象时：
```
new ClassName();
```
将会为对象分配存储空间，并调用相应的构造器。构造器是一种特殊的方法，没有返回值（这与返回值为空（void）不同）。
不接受任何参数的构造器叫做默认构造器，Java术语为无参构造器。

## 方法重载
重载，用于表示相同但有细微差别的概念。将方法重载用于构造器，可以提供创建对象的多种方式，非构造器方法也可以使用。
区分重载方法：每个重载的方法都必须有一个独一无二的参数类型列表。而且，参数顺序也可以区分（不过，一般情况别这么做，会使代码难以维护）。但是，返回值是不能用于区分重载的。
基本类型的重载，基本类型能从一个“较小”的类型自动提升至一个“较大”的类型。char略有不同，如果找不恰好接收char参数的方法，会提升为int。基本类型很有必要从[这里学习](http://www.runoob.com/java/java-basic-datatypes.html)。

## 默认构造器
如果，你的类的中没有写构造器，则编译器就会自动帮你创建一个默认构造器；但是，如果你定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器了。

## this关键字
this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。
不过，在方法内部调用同一个类的另一个方法，就不必使用this了，因为编译器自动帮你添加。只有当需要明确指出对当对象的引用时，才需要使用this，如：
```
public class Lear{
  int i;
  Leaf increament(){
     i++;
     return this;
  }
}
```
this关键字对于将当前对象传递给其他方法也很有用。
```
public class ThisDemo {
    public static void main(String[] args) {
        Person person = new Person();
        person.eat(new Apple());
    }
}

class Person {
    public void eat(Apple apple) {
        Apple peeled = apple.getPeeled();
        System.out.println("Yummy");
    }
}

class Apple {
    Apple getPeeled() {
        return Peeler.peel(this);
    }
}

class Peeler {
    static Apple peel(Apple apple) {
        // remove peel
        return apple;
    }
}  /*output:
Yummy
*///:~
```
this还用与在构造器中调用构造器。

### static的含义
static方法，就是没有this的方法。

## 清理：终结处理和垃圾回收
Java垃圾回收器负责回收无用对象占据的内存资源。
但是，也有特殊情况，假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放经由new分配的内存，所以它不知道如何释放这样的“特殊”内存。

A a = new A(1);
a = new A(2); // new A(1)产生的对象将被丢弃，并等待回收（如果没有别的引用关联它）。

## 成员初始化
Java尽力保证：所有变量在使用前都能得到恰当的初始化。
对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。
对于类的数据成员（即字段），如果是基本类型，在创建对象时会有一个初始值（数字类型为0，布尔为false，char为0且打印为空白）；如果是引用类型，就会获得一个特殊值null。

## 构造器初始化
可以使用构造器来进行初始化。但是，这无法阻止自动初始化的进行，成员初始化在构造初始化之前进行。
### 初始化顺序
在类内部，变量定义的先后顺序决定了初始化的顺序。
即使，变量定义方法定义之间，他们仍旧会在任何方法（包括构造器）被调用之前得到初始化。
### 静态数据的初始化
静态变量只在类的第一个对象（或者第一次访问静态数据）的时候被初始化，此后无论创建多少对象，都不会再次被初始化，因此静态数据只占用一份内存区域。
static关键字不能应用于**局部变量**，只能作用于**域**。（注意Java术语）。
**对象创建过程**，假设有个名为Dog的类：

1. 当**首次**创建类型为Dog的对象时，或者Dog类的静态方法/静态域**首次**被访问时，Java解释器必须查找类路径，已定位Dog.class文件。
2. 然后载入Dog.class，有关静态初始化的多有动作都会执行。因此静态初始化只在Class对象首次加载的时候执行一次。
3. 当用new Dog()创建对象时，首先在堆上为Dog对象分配足够的存储空间。
4. 这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据设置为默认值，而引用则被设置为null。
5. 执行所有出现于字段定义处的初始化动作。
6. 执行构造器。

### 显式静态初始化
Java允许将多个静态初始化动作组织成一个特殊的“静态字句”（静态块）。就像下面这样：
```
public class StaticDemo{
  static int i;
  static{
    i=47;
  }
}
```
尽管看上去像个方法，但实际只是一段跟在static后的代码。
### 非静态实例初始化
**实例**初始化。初始化每个对象的非静态变量。

## 数组初始化
数组，相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。
定义数组：
```
int[] a;
int a1[];
```
编译器不允许定义数组时指定大小。现在拥有的就是一个引用，这和其他类的引用和对象是一样的。
为了给数组分配存储空间，必须写初始化表达式：
```
a = new int[2]; // 数组定义之后的任意地方都可以使用
int[] a2 = {0, 1}; // 这种初始化方式只能在数组定义时使用
```
### 可变参数列表
```
public class NewVarArgs {

    // 可变参数列表
    static void printArray(Object... args) {
        for (Object o : args) {
            System.out.print(o);
        }
        System.out.println();
    }

    public static void main(String[] args) {
        printArray(new Integer(47), new Float(3.14), new Double(11.11));
        printArray(47, 3.14, 11.11);
        printArray("one", "two");
        // 数组
        printArray(new Integer[] { 1, 2, 3 });
        printArray();
    }
}
```
如果你有一组事务，可以把它们作为列表传递；而如果你已经有一个数组，该方法可以把它们作为可变参数列表来接受。
## 枚举类型


# 复用类

## 组合语法
将对象引用置于新类中就是使用组合。

## 继承语法
继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类的时候，总是在继承，除非已明确指出要从其他类继承，否则就是在隐式的从Java的标准根类Object进行继承。

组合的语法比较平实，但继承是使用特殊的一种语法，即**extends**。
### 初始化基类
当创建一个导出类的对象时，该对象会包含一个基类的子对象。这个子对象与用基类直接创建对象是一样的，但这个子对象被包装在导出类对象内部。因此，对基类子对象的初始化也至关重要，而且也仅有一种方法：
在构造器中调用基类的构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力。

当读到这句话的时候，它对自己有一定的触动。因为，在以往的编程经历中，设计一个类的时候，几乎都忽略了构造器的这种能力。

对于基类默认构造器，Java会自动在导出类的构造器中插入对基类构造器的调用。
对于基类带参数的构造器，必须使用关键字**super**显式的编写调用基类构造器的语句。而且，调用基类构造器必须位于导出类构造器中的最前面。否则，编译报错。
```
Demo(int i){
  super(i);  // 第一句
  // 其他处理
}
```

## 代理
将一个成员对象置于所要构造的新类中（就像组合），与此同时在新类中暴露了该成员对象的所有方法（就像继承）。（当然，不一定是所有方法）

书中太空船的例子。
```
/**
 * 太空船控制模块
 * 
 * @author rengzailushang
 *
 */
public class SpaceShipControls {
	void forward(int velocity) {
	}
	void back(int velocity) {
	}
}
```
如果使用继承，
```
/**
 * 使用继承建造太空船
 * 
 * @author rengzailushang
 *
 */
public class SpaceShip extends SpaceShipControls{
	private String name;
	public SpaceShip(String name) {
		this.name = name;
	}
}
```
然后，SpaceShip并非真正的SpaceShipControls类型。所以，代理可以解决这一问题：
```
/**
 * 使用代理建造太空船
 * 
 * @author rengzailushang
 *
 */
public class SpaceShip2 {
	private String name;
	private SpaceShipControls control = new SpaceShipControls();
	public SpaceShip2(String name) {
		this.name = name;
	}
	public void forward(int velocity) {
		control.forward(velocity);
	}
	public void back(int velocity) {
		control.back(velocity);
	}
}
```
书中还提到，尽管Java语言不直接支持代理，但是很多工具如JetBrains Idea IDE等可以自动生成上述例子。不过我没有去学习。

## 结合使用组合和继承
### 确保正确的清理
前面“初始化与清理”中，我们不知道Java垃圾回收器何时被调用，或者它是否被调用。因此，如果你想要某个类清理一些东西，就必须显式的编写一个特殊的方法来做这个事情，不要使用**finalize()**。
### 名称屏蔽
如果Java的基类中拥有某个已被多次重载的方法，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。如果不想重载，可以使用@Override注解。
```
public class OverrideDemo extends BaseClass{
	//@Override
	//void base(String i){} // 基类中必须有可重写的方法，否则编译报错
	
	@Override
	void base(int i){}
}

class BaseClass {
	void base(int i){}
}
```

## 在组合与继承之间选择
组合，通常用于想在新类中使用现有类的功能而非它的接口的情形。并且，一般组合成员都使用private，以隐藏具体实现。但是有时为了帮助该新类的使用者去了解怎么使用，也可以设置成public，但这是个例。

继承，使用某个现有类，并开发一个它的特殊版本。

"is-a"(是一个)的关系是用继承来表达，而“has-a”(有一个)的关系则用组合来表达。就像“车子”是一个“交通工具”，“太空船”有一个“控制模块”。

## protected关键字
书中这样讲，“现在，我们以介绍完了继承，关键字**protected**最终具有了意义。”，我觉得这真是一种讲解的技巧。

在实际项目中，经常会想到将某些事物尽可能对世界隐藏起来，但仍然允许导出类的成员访问它们。**protected**就是这个作用。另外，protected也提供了包内访问权限。

最好的方式，还是将域保持为**private**：你应当一直保留“更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限。

## 向上转型
继承技术最重要的就是，表现新类与基类间的关系，即“新类是现有类的一种类型”。

为什么叫“向上转型”？
传统的类继承图绘制：将根置于页面的顶端，然后逐渐向下。所以，由导出类转型为基类，在继承图上是向上移动的，因此为向上转型。
向上转型，是从一个专用类向较通用的类转换，所以总是安全的。

**是否真的需要向上转型**也是判断是否应当使用继承的方法。虽然继承是OOP的重要技术与思想，但是并不意味着尽可能使用，相反，应慎用。

## final关键字
### final数据
1. 编译时常量
这种final数据，必须是基本类型，且在定义时必须赋值。编译器可以将常量代入到任何用到它的计算式中，这减轻了运行时的负担。

2. final引用类型
不变的是引用，不是对象。

3. 空白final
可以在定义时不进行赋值，但是在构造器中必须赋值。

4. final参数
在方法中，参数的值不能修改。
### final方法
1. 方法锁定
以防继承类修改它的含义。
类中所有的private方法都隐式的使用了final。

2. 效率
正常方式的执行方法调用机制是，将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值。在早期的java版本中，final方法可以跳过这一步骤。但是，在Java5/6时，虚拟机会自动处理效率问题，我们无需使用final去提高效率。
### final类
不可被继承。

## 初始化及类的加载
每个类的编译代码都存在于它自己独立的文件中，该文件只在需要使用程序代码时才会被加载。加载发生于：

1. 创建类的第一个对象时，
2. static域或static方法被访问时（构造器也是static方法，尽管没有显式的使用static关键字）。
所有的static对象和static代码段都会在加载时依程序中的顺序而以此初始化。

通过一个例子了解包括继承在内的初始化过程。
```
/**
 * 继承与初始化
 * 
 * @author rengzailushang
 *
 */
public class Beetle extends Insect {
	private int k = printInit("Beetle.k initialized");
	public Beetle() {
		System.out.println("k=" + k);
		System.out.println("j=" + j);
	}
	public static int x2 = printInit("Beelte.x2 initialized");
	public static void main(String[] args) {
		System.out.println("Beetle constructor");
		Beetle b = new Beetle();
	}
}

class Insect {
	private int i = 9;
	protected int j;
	Insect() {
		System.out.println("i=" + i + ",j=" + j);
		j = 39;
	}
	public static int x1 = printInit("Insect.x1 initialized");
	static int printInit(String s) {
		System.out.println(s);
		return 47;
	}
} /* Output:
Insect.x1 initialized
Beelte.x2 initialized
Beetle constructor
i=9,j=0
Beetle.k initialized
k=47
j=39
*///:~
```

1. 访问Beetle.main()(static方法)，加载器启动并找出Beetle类的编译代码。加载Beetle类，发现它有一个基类，于是继续加载基类（如果基类仍有基类，则继续加载，如此类推）。
2. 根基类static初始化，下一个导出类，如此类推。
3. 类加载完后，开始创建Beetle对象，首先对象中的成员被设为默认值（即便定义时被赋值，也要先设为默认值，再初始化）。
4. Beetle构造器被调用，先调用基类构造器（super()），基类中与3、4同。
5. 基类构造器完成后，Beetle实例变量初始化，然后再执行构造器中的其他部分。

## 总结
组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口。

开始设计时，优先考虑组合（或代理），只有确实必要时才使用继承。在设计一个系统时，目标应该是找到或创建某些类，每个类都有具体的用途，既不会太大（功能太多而难以复用），也不会太小。

当开始设计一个系统时，应该意识到程序开发是一种增量过程，而不是快速见效。

（对于我来说，这段总结值得思考，我经常在开始开发一个项目或功能时，追求过于全面的考虑）